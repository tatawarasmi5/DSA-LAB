#include <iostream>
#include <string>
using namespace std;

const int MAX_SIZE = 50;

class Stack {
private:
    char arr[MAX_SIZE];
    int top;

    int isOperator(char ch) {
        return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '%' || ch == '^');
    }

    int isOperand(char ch) {
        return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9'));
    }

    int precedence(char op) {
        if (op == '+' || op == '-') return 1;
        if (op == '*' || op == '/' || op == '%') return 2;
        if (op == '^') return 3;
        return 0;
    }

    // Manual exponentiation (no cmath)
    int power(int base, int exp) {
        int result = 1;
        for (int i = 0; i < exp; i++)
            result *= base;
        return result;
    }

public:
    Stack() {
        top = -1;
    }

    int isEmpty() {
        return (top == -1);
    }

    int isFull() {
        return (top == MAX_SIZE - 1);
    }

    void push(char ch) {
        if (!isFull())
            arr[++top] = ch;
    }

    char pop() {
        if (isEmpty())
            return '\0';
        return arr[top--];
    }

    char peek() {
        if (isEmpty())
            return '\0';
        return arr[top];
    }

    string infixToPostfix(const string& infix) {
        string postfix_output = "";

        for (char ch : infix) {
            if (isOperand(ch)) {
                postfix_output += ch;
            } else if (ch == '(') {
                push(ch);
            } else if (ch == ')') {
                while (!isEmpty() && peek() != '(')
                    postfix_output += pop();
                if (!isEmpty() && peek() == '(')
                    pop();
            } else if (isOperator(ch)) {
                while (!isEmpty() && peek() != '(' &&
                       precedence(ch) <= precedence(peek()))
                    postfix_output += pop();
                push(ch);
            }
        }

        while (!isEmpty())
            postfix_output += pop();

        cout << "Postfix expression: " << postfix_output << endl;
        return postfix_output;
    }

    int evaluatePostfix(const string& postfix) {
        int valStack[MAX_SIZE];
        int valTop = -1;

        auto pushVal = [&](int v) { valStack[++valTop] = v; };
        auto popVal = [&]() -> int { return valStack[valTop--]; };

        for (char ch : postfix) {
            if (ch >= '0' && ch <= '9') {
                pushVal(ch - '0');
            } else if (isOperator(ch)) {
                int val2 = popVal();
                int val1 = popVal();
                int result = 0;

                switch (ch) {
                    case '+': result = val1 + val2; break;
                    case '-': result = val1 - val2; break;
                    case '*': result = val1 * val2; break;
                    case '/': result = val2 != 0 ? val1 / val2 : 0; break;
                    case '%': result = val2 != 0 ? val1 % val2 : 0; break;
                    case '^': result = power(val1, val2); break;
                }
                pushVal(result);
            }
        }

        return valStack[valTop];
    }
};

int main() {
    string expression;
    cout << "Enter infix expression: ";
    cin >> expression;

    Stack s;
    string postfix = s.infixToPostfix(expression);

    bool numeric = true;
    for (char c : postfix) {
        if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
            numeric = false;
            break;
        }
    }

    if (numeric) {
        int result = s.evaluatePostfix(postfix);
        cout << "Evaluated result: " << result << endl;
    } else {
        cout << "Evaluation skipped" << endl;
    }

    return 0;
}
